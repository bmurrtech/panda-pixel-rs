name: release

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        platform: [macos-latest, ubuntu-latest, windows-latest]

    runs-on: ${{ matrix.platform }}

    env:
      # Ensure sccache is used by Cargo for all build steps
      RUSTC_WRAPPER: sccache

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Rust (pinned toolchain)
        uses: dtolnay/rust-toolchain@stable
        with:
          # Pin to specific version for reproducible builds
          # Current: 1.89.0 (update when upgrading Rust)
          toolchain: 1.89.0

      - name: Install sccache
        uses: mozilla-actions/sccache-action@v0.0.4

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          cache-all-crates: true

      - name: Install WASM target
        run: rustup target add wasm32-unknown-unknown

      - name: Install Linux dependencies
        if: matrix.platform == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libgtk-3-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf \
            nasm

      - name: Install Trunk (cached, pinned version)
        uses: taiki-e/cache-cargo-install-action@v2
        with:
          # Pin trunk version for reproducible builds
          # Current: 0.21.14 (check https://crates.io/crates/trunk for updates)
          tool: trunk@0.21.14

      - name: Install Tauri CLI (cached, pinned version)
        uses: taiki-e/cache-cargo-install-action@v2
        with:
          # Pin tauri-cli version matching Tauri 2.0
          # Current: 2.5.0 (check https://crates.io/crates/tauri-cli for updates)
          tool: tauri-cli@2.5.0

      - name: Build frontend (Unix)
        if: matrix.platform != 'windows-latest'
        run: ./build-frontend.sh

      - name: Build frontend (Windows)
        if: matrix.platform == 'windows-latest'
        shell: pwsh
        run: ./build-frontend.ps1

      - name: Build Tauri app (release with ThinLTO)
        working-directory: src-tauri
        shell: bash
        run: |
          # Configure ThinLTO for release build (mirrors local: cargo build --release --config profile.release.lto="thin")
          # Force bash shell for cross-platform heredoc support (Windows runners have bash via Git for Windows)
          mkdir -p .cargo
          cat > .cargo/config.toml << 'EOF'
          [profile.release]
          lto = "thin"
          EOF
          # Build exactly as local: cargo tauri build
          cargo tauri build

      - name: Package macOS .app as zip
        if: matrix.platform == 'macos-latest'
        shell: bash
        run: |
          set -euxo pipefail
          APP_FOUND=false
          DMG_FOUND=false
          # Search both possible locations
          for root in target/release/bundle src-tauri/target/release/bundle; do
            if [[ -d "$root" ]]; then
              # Check for .dmg first (some bundler configs produce only .dmg)
              if find "$root" -type f -name "*.dmg" -maxdepth 5 | head -n 1 | grep -q .; then
                DMG_FOUND=true
                echo "Found .dmg in $root"
              fi
              # Check for .app to package as zip
              APP_DIR=$(find "$root" -type d -name "*.app" -maxdepth 5 | head -n 1 || true)
              if [[ -n "$APP_DIR" ]]; then
                echo "Found .app at: $APP_DIR"
                ditto -c -k --sequesterRsrc --keepParent "$APP_DIR" "${APP_DIR}.zip"
                echo "Created zip: ${APP_DIR}.zip"
                APP_FOUND=true
                break
              fi
            fi
          done
          # Fail-fast: must find either .app (to zip) or .dmg
          if [[ "$APP_FOUND" != "true" && "$DMG_FOUND" != "true" ]]; then
            echo "ERROR: No .app bundle or .dmg found for macOS packaging"
            exit 1
          fi

      - name: Find bundle artifacts (fail-fast if empty)
        id: find-artifacts
        shell: bash
        run: |
          set -euxo pipefail
          
          # Search both possible target locations
          ROOTS=("target/release/bundle" "src-tauri/target/release/bundle")
          
          collect() {
            local pattern="$1"
            local found=""
            for r in "${ROOTS[@]}"; do
              if [[ -d "$r" ]]; then
                found_files=$(find "$r" -type f $pattern 2>/dev/null || true)
                if [[ -n "$found_files" ]]; then
                  found="${found}${found_files}"$'\n'
                fi
              fi
            done
            echo "$found" | grep -v '^$' || true
          }
          
          if [[ "${{ matrix.platform }}" == "macos-latest" ]]; then
            ARTIFACTS=$(collect "\( -name \"*.dmg\" -o -name \"*.app.zip\" \)")
          elif [[ "${{ matrix.platform }}" == "windows-latest" ]]; then
            ARTIFACTS=$(collect "\( -name \"*.exe\" -o -name \"*.msi\" \)")
          else
            ARTIFACTS=$(collect "\( -name \"*.deb\" -o -name \"*.rpm\" -o -name \"*.AppImage\" -o -name \"*.tar.gz\" \)")
          fi
          
          # Fail-fast: artifacts must be non-empty
          if [[ -z "$ARTIFACTS" ]]; then
            echo "ERROR: No artifacts found for platform ${{ matrix.platform }}"
            echo "Searched in: ${ROOTS[*]}"
            exit 1
          fi
          
          # Output multiline format (robust for paths with spaces, works with softprops)
          # Use heredoc syntax for $GITHUB_OUTPUT to handle multiline values
          {
            echo "artifacts<<EOF"
            echo "$ARTIFACTS"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          
          echo "Found artifacts:"
          echo "$ARTIFACTS"

      - name: Upload artifacts
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          name: ${{ github.ref_name }}
          draft: false
          prerelease: true
          generate_release_notes: true
          files: ${{ steps.find-artifacts.outputs.artifacts }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
